1. jinfo https://www.jianshu.com/p/8d8aef212b25
2. 内存溢出
    1。 需要找出 浅堆很小，深堆很大的对象，把他们干掉。可以通过MAT去搞




3. 怎么找到垃圾：
    1> 引用计数，python还在用。解决不了环形引用的问题[环上的全是垃圾]
    2> 根可达算法[java用的，来自于java虚拟机规范]
4. 垃圾清除算法：
    1> mark-sweep 标记清除。简单速度快。问题：内存碎片  [一般用在年老代]
    2> copy  复制。简单速度快。问题： 浪费内存 [一般在年轻代]
    3> mark-compact：标记压缩  既不会有碎片又不会浪费内存。问题：效率低 [一般用在年老代]
5. TLAB是eden的一部分。 每个线程都会有自己的一部分
    TLAB也又自己的缺点。因为TLAB通常很小，所以放不下大对象。
    1，TLAB空间大小是固定的，但是这时候一个大对象，我TLAB剩余的空间已经容不下它了。(比如100kb的TLAB，来了个110KB的对象)
    2，TLAB空间还剩一点点没有用到，有点舍不得。(比如100kb的TLAB，装了80KB，又来了个30KB的对象)
    所以JVM开发人员做了以下处理，设置了最大浪费空间。
    当剩余的空间小于最大浪费空间，那该TLAB属于的线程在重新向Eden区申请一个TLAB空间。进行对象创建，还是空间不够，那你这个对象太大了，去Eden区直接创建吧！
    当剩余的空间大于最大浪费空间，那这个大对象请你直接去Eden区创建，我TLAB放不下没有使用完的空间。
    当然，又回造成新的病垢。
    3，Eden空间够的时候，你再次申请TLAB没问题，我不够了，Heap的Eden区要开始GC，
    4，TLAB允许浪费空间，导致Eden区空间不连续，积少成多。以后还要人帮忙打理。
6. jdk1.8 默认用的是 Parallel Scavenge [年轻代]  Parallel Old [年老代]，简称 useParallel
   一般用 ParNew[专门配合cms使用，和 ps 一样] + CMS，



other : -XX:MaxTenuringThreshold=threshold [cms 默认是6，其他都是15]  在新生代中对象存活次数(经过Minor GC的次数)后仍然存活，就会晋升到旧生代。