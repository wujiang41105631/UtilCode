# mysql问题
1. B+树与B树的不同在于：
    B+ 树是一种多路平衡查找树：B+数据存储在叶子节点，而B树的数据在所有节点上都能存放。2》 通过链表的方式吧叶子节点的数据串在了一块。B+ tree的子树数量=关键字数
   （1）叶子节点会包含所有的数据，并且叶子节点本身是根据关键字的大小从小到大顺序链接。
   （2）为所有叶子节点增加了一个双向链指针
   为什么做以上两个优化
   1.B+树非叶子节点不存储数据，所以每一层能够存储的索引数量会增加，意味b+树在层高相同的情况下存储数据量要比b树要多，使得磁盘io次数更少
   2.Mysql中，范围查询时一个比较常用的操作，而b+树的所有存储在叶子节点的数据使用了双向链表来关联，所以在查询的时候只需要查两个节点进行遍历就行，而b需要获取到所有的节点，所以b+树在范围查询效率更高。
   3.在数据检索方面，由于所有的数据都存储在叶子节点，所以b+树的io次数会更加稳定一些。
   4.因为叶子节点存储所有数据，所有b+树的全局扫描能更强一些，因为它只需要扫描叶子节点，但b树需要遍历整个树。
   
2. innodb和myisam区别：  
   - MySQL默认采用的是MyISAM。 
   - MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。
   - InnoDB支持数据行锁定和表锁定，MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。
   - InnoDB支持外键，MyISAM不支持。 InnoDB的主键范围更大，最大是MyISAM的2倍。
   - InnoDB不支持全文索引，而MyISAM支持。全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉（mysql 5.6 以后innodb也支持全文索引了）。
   - MyISAM支持GIS数据，InnoDB不支持。即MyISAM支持以下空间数据对象：Point,Line,Polygon,Surface等。
   - 没有where的count(*)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(*)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(*)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary
     cindex是和raw data存放在一起的，而secondary
     index则是单独存放，然后有个指针指向primary
     key。所以只是count(*)的话使用secondary index扫描更快，而primary
     key则主要在扫描索引同时要返回raw data时的作用较大。
    
    
    Write-Ahead Logging 简称WAL
    A 原子性 wal undolog
    C 一致性 wal  一致性是指系统从一个正确的状态,迁移到另一个正确的状态，
                    所谓⼀致性是数据库处理前后结果应与其所抽象的客观世界中真实状况保持⼀致。
                    这种⼀致性是⼀种需要管理员去定义的规则。管理员如何指定规则，数据库就严格按照这种规则去处理数据。
                    就拿那个⽼掉⽛的AB转账来进⼀步解释，如果说AB账户总⾦额5000就是数据库的⼀致性规则，那么我能不能把A账户转⾛10000给B，
                    让B账户有10000，⽽A剩下-5000？从数学上来看完全正确，但这显然是不符合常理的。⽽这种常理，就是所谓的⼀致性。
    I 隔离性 锁
    D 持久性 wal  redolog
    
    事务的实现方式：
    原子性（Atomicity）：语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的。实现主要基于undo   log日志。
    持久性（Durability）：保证事务提交后不会因为宕机等原因导致数据丢失。实现主要基于redo log日志。
    隔离性（Isolation）：保证事务执行尽可能不受其他事务影响。InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制、数据的隐藏列、undo log和类next-key lock机制。
    一致性（Consistency）：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障。

3. 事务的隔离级别   
   1> 读未提交  
   2> 读已提交[大多数数据库的默认事务隔离级别] 解决了脏读的问题 无GAP锁  
   3> 可重复读[mysql的默认事务隔离级别]
   解决了不可重复度和脏读的问题[通过MVCC解决了不可重复度]
   此阶段可以通过next_key锁解决幻读问题  ，读可以分为快照读和当前读，如果是范围内的幻读问题可以通过next-key锁搞定幻读的问题
   4> 串行化 解决了脏读，幻读，不可重复度 的问题【默认所有的select语句都会被隐式的加上lock in share mode,会和update,delete互斥】  
   
   针对问题： 1> 脏读: 读到了未提交的数据  
   2> 幻读: 同一事务中读到了另外一个事务新插入的数据  
   3> 不可重复度:同一事务中读到了另外一个事务update或delete的数据  
   4> mysql 每行数据都会带3个字段 _rowid,tx_id,roll_ptr,至少innodb是这样
4. mysql锁[按粒度分]
    * 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
    * 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
    * 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般  
    1> myisam 是表级锁  
    2> innodb是行级锁:  
     innoDB实现了以下两种类型的行锁。
     共享锁（s）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 [lock in share mode]
     排他锁（Ｘ）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。 [for update]
     另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。这个是存储引擎或者数据库自己实现的。
     意向锁的目的是为了提升加表锁的效率的标志
     意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
     意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。  

 | 前锁模式/是否兼容/请求锁模式 | X | IX | S | IS |
 | :--: | :--: | :--: | :--: | :--: |
 | X | 冲突 | 冲突 | 冲突 | 冲突 |
 | IX | 冲突 | 兼容 | 冲突 | 兼容 |
 | S | 冲突 | 冲突 | 兼容 | 兼容 |
 | IS | 冲突 | 兼容 | 兼容 | 兼容 |  
    3> Innodb 锁的算法：   
        1>> 锁记录(锁的实际上是索引)  条件： 精准匹配 相当于 == 才会用到记录锁  
        2>> 间隙锁：锁定的是数据不存在的一个区间范围，阻塞插入，
            锁的时候会从真正的数据开始，且左右都是开区间(GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。)[n个数据，有n+1个间隙锁]条件：区间  
        3>> next-key 临键锁(并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。)条件：范围查询，包含记录和区间，左开右闭     
    详见 [mysql 锁](http://hedengcheng.com/?p=771#_Toc374698322)  
5. MVCC  
   同一个事务中
   在 读已提交 的模式下，每次查询都会生成新的快照
   在 可重复读 的模式下，只会生成一个快照 ，但能读到自身事务写的数据
   通过txId和undo.log实现
   
   多版本并发控制：   
   在查询时要符合以下两个条件的记录才能被事务查询出来：  
   1>
   删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)
   创建版本号 小于或者等于  
   2>当前事务版本号，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert
   
6. 数据库的锁到底锁了什么东西：
     锁的是索引   
7。 聚集索引：  
    一张表一定有索引 ，为聚集索引 
    1> primary key   
    2> unique key 不为空  
    3> 表自带的 _rowid    
    二级索引：     
补充：   
1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.  
2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。
3.串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。
4.通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。

------------------------------------------------------------------------------------------------------------------------------------------------------------------
索引：  
    索引是什么？ 索引是为了加速对表中数据行的检索而创建的一种数据结构，索引是帮助mysql高效获取数据的排好序的数据结构
    
    1。 范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引   
    2。 如果是范围查询和等值查询同时存在，优先匹配等值查询列的索引
    3。 区分度不大的字段上不宜建立索引：类似于性别这种区分度不大的字段，建立索引的意义不大。因为不能有效过滤数据，性能和全表扫描相当。另外返回数据的比例在30%以外的情况下，优化器不会选择使用索引
    
关于for update的锁问题
1. 如果查询条件没有查到数据，则 无锁。
2. 查到数据的时候 ，看查询条件是否在索引中，如果有则是行锁，否则是表锁。
3. 当使用<> 或 like 等字段时，是表锁。


mysql 查询慢的问题：
 - sql层面： 主要是索引的问题
 - mysql架构层面
       - 读写分离，做主从
       - 分库分表
       - 热点数据打缓存
 - 服务器层面
      网络问题
      硬盘问题
      cpu问题 SSD 
 
为什么MySQL不推荐使用uuid作为主键?
      1）使用自增id的内部结构

      自增的主键的值是顺序的，所以Innodb把每一条记录都存储在一条记录的后面。当达到页面的最大填充因子时候(innodb默认的最大填充因子是页大小的15/16，会留出1/16的空间留作以后的修改)：

    ①下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费

    ②新插入的行一定会在原有的最大数据行下一行，mysql定位和寻址很快，不会为计算新行的位置而做出额外的消耗

    ③减少了页分裂和碎片的产生

     2）使用uuid的索引内部结构

为什么不用UUID做主键？
因为uuid相对顺序的自增id来说是毫无规律可言的，新行的值不一定要比之前的主键的值要大，所以innodb无法做到总是把新行插入到索引的最后，而是需要为新行寻找新的合适的位置从而来分配新的空间。
这个过程需要做很多额外的操作，数据的毫无顺序会导致数据分布散乱，将会导致以下的问题：
①写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO
②因为写入是乱序的，innodb不得不频繁的做页分裂操作，以便为新的行分配空间，页分裂导致移动大量的数据，一次插入最少需要修改三个页以上
③由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片
在把随机值（uuid和雪花id）载入到聚簇索引(innodb默认的索引类型)以后，有时候会需要做一次OPTIMEIZE TABLE来重建表并优化页的填充，这将又需要一定的时间消耗。
结论：使用innodb应该尽可能的按主键的自增顺序插入，并且尽可能使用单调的增加的聚簇键的值来插入新行
3）使用自增id的缺点
那么使用自增的id就完全没有坏处了吗？并不是，自增id也会存在以下几点问题：
①别人一旦爬取你的数据库，就可以根据数据库的自增id获取到你的业务增长信息，很容易分析出你的经营情况
②对于高并发的负载，innodb在按主键进行插入的时候会造成明显的锁争用，主键的上界会成为争抢的热点，因为所有的插入都发生在这里，并发插入会导致间隙锁竞争
③Auto_Increment锁机制会造成自增锁的抢夺，有一定的性能损失
附：Auto_increment的锁争抢问题，如果要改善需要调优innodb_autoinc_lock_mode的配置

binlog类型：
    show variables like 'binlog_format'
1.Statement：每一条会修改数据的sql都会记录在binlog中。
优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所产生的日志量会增加多少，以及带来的IO性能问题。)
缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，
        以保证所有语句能在slave得到和在master端执行时候相同的结果。
        另外mysql 的复制,像一些特定函数功能(update t set  t.a = '123' where update_time = now())，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).

2.Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。(仅需要记录那一条记录被修改成什么了)
优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题
缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。

3.Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更

undo log,redo log ,bin log 区别
UndoLog也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由引擎层的InnoDB引擎实现,是逻辑日志.
redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。
redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑
redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。
binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。