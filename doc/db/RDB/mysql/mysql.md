# mysql问题
1. B+树与B树的不同在于：
   （1）所有关键字存储在叶子节点，非叶子节点不存储真正的data
   （2）为所有叶子节点增加了一个链指针
2. innodb和myisam区别：  
   - MySQL默认采用的是MyISAM。 
   - MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。
   - InnoDB支持数据行锁定和表锁定，MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。
   - InnoDB支持外键，MyISAM不支持。 InnoDB的主键范围更大，最大是MyISAM的2倍。
   - InnoDB不支持全文索引，而MyISAM支持。全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉（mysql 5.6 以后innodb也支持全文索引了）。
   - MyISAM支持GIS数据，InnoDB不支持。即MyISAM支持以下空间数据对象：Point,Line,Polygon,Surface等。
   - 没有where的count(*)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(*)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(*)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary
     cindex是和raw data存放在一起的，而secondary
     index则是单独存放，然后有个指针指向primary
     key。所以只是count(*)的话使用secondary index扫描更快，而primary
     key则主要在扫描索引同时要返回raw data时的作用较大。
    
    
    Write-Ahead Logging 简称WAL
    A 原子性 wal
    C 一致性 wal  一致性是指系统从一个正确的状态,迁移到另一个正确的状态
    I 隔离型 锁
    D 持久性 wal

3. 事务的隔离级别   
   1> 读未提交  
   2> 读已提交[大多数数据库的默认事务隔离级别] 解决了脏读的问题 无GAP锁  
   3> 可重复读[mysql的默认事务隔离级别]
   解决了不可重复度和脏读的问题[通过MVCC解决了不可重复度]
   此阶段可以通过next_key锁解决幻读问题  
   4> 串行化 解决了脏读，幻读，不可重复度 的问题【默认所有的select语句都会被隐式的加上lock in share mode,会和update,delete互斥】  
   
   针对问题： 1> 脏读: 读到了未提交的数据  
   2> 幻读: 同一事务中读到了另外一个事务新插入的数据  
   3> 不可重复度:同一事务中读到了另外一个事务update或delete的数据  
   4> mysql 每行数据都会带3个字段 _rowid,tx_id,roll_ptr,至少innodb是这样
4. mysql锁[按粒度分]
    * 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
    * 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
    * 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般  
    1> myisam 是表级锁  
    2> innodb是行级锁:  
     innoDB实现了以下两种类型的行锁。
     共享锁（s）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 [lock in share mode]
     排他锁（Ｘ）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。 [for update]
     另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。这个是存储引擎或者数据库自己实现的。
     意向锁的目的是为了提升加表锁的效率的标志
     意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
     意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。  

 | 前锁模式/是否兼容/请求锁模式 | X | IX | S | IS |
 | :--: | :--: | :--: | :--: | :--: |
 | X | 冲突 | 冲突 | 冲突 | 冲突 |
 | IX | 冲突 | 兼容 | 冲突 | 兼容 |
 | S | 冲突 | 冲突 | 兼容 | 兼容 |
 | IS | 冲突 | 兼容 | 兼容 | 兼容 |  
    3> Innodb 锁的算法：   
        1>> 锁记录(锁的实际上是索引)  条件： 精准匹配 相当于 == 才会用到记录锁  
        2>> 间隙锁：锁定的是数据不存在的一个区间范围，阻塞插入，锁的时候会从真正的数据开始，且左右都是开区间(GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。)[n个数据，有n+1个间隙锁]条件：区间  
        3>> next-key 临键锁(并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。)条件：范围查询，包含记录和区间，左开右闭     
    详见 [mysql 锁](http://hedengcheng.com/?p=771#_Toc374698322)  
5. MVCC   
   通过txId和undo.log实现
   多版本并发控制：   
   在查询时要符合以下两个条件的记录才能被事务查询出来：  
   1>
   删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)
   创建版本号 小于或者等于  
   2>当前事务版本号，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert
   
   
   redolog是物理更改 binlog是逻辑更改 undo是更改后的数据历史快照
   redolog是对物理页的更改
   undolog 是更改后的数据历史快照
   binlog记录sql语句和更改行数
   
   
     
6. 数据库的锁到底锁了什么东西：
     锁的是索引   
7。 聚集索引：  
    一张表一定有索引 ，为聚集索引 
    1> primary key   
    2> unique key 不为空  
    3> 表自带的 _rowid    
    二级索引：     
补充：   
1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.  
2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。
3.串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。
4.通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。

------------------------------------------------------------------------------------------------------------------------------------------------------------------
索引：  
    索引是什么？ 索引是为了加速对表中数据行的检索而创建的一种数据结构，索引是帮助mysql高效获取数据的排好序的数据结构