https://www.cnblogs.com/stateis0/category/1206895.html
1. CAP  理论： 系统设计一般3选2
   1> C : 一致性：强一致性，即每次写完成以后读到的数据一定是上次写入的数据。
   2> A : 可用性，指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据。
   3> P ：分区容错性：分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障
   其中分区是指：在分布式系统中，不同的节点分布在不同的子网络中，每个子网络就叫做一个区,由于一些特殊的原因，这些区之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域。这就是分区。
仔细想想，分区是百分之百出现的吗？如果不出现分区，那么就能够同时满足 CAP。如果出现了分区，可以根据策略进行调整。比如 C 不必使用那么强的一致性，可以先将数据存起来，稍后再更新，实现所谓的 “最终一致性”。就是BASE理论。
2. BASE 理论：
    Basically Available(基本可用)
        什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：
        响应时间上的损失：正常情况下的搜索引擎 0.5 秒即返回给用户结果，而基本可用的搜索引擎可以在 1 秒作用返回结果。
        功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单，但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。
    Soft state（软状态）
        什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。
        软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。
    Eventually consistent（最终一致性）
        系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值。
        而在实际工程实践中，最终一致性分为 5 种：
        1. 因果一致性（Causal consistency）
        指的是：如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。
        2. 读己之所写（Read your writes）
        这种就很简单了，节点 A 更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。
        3. 会话一致性（Session consistency）
        会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。
        4. 单调读一致性（Monotonic read consistency）
        单调读一致性是指如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。
        5. 单调写一致性（Monotonic write consistency）
        指一个系统要能够保证来自同一个节点的写操作被顺序的执行。
        然而，在实际的实践中，这 5 种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的，比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。
    Base 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的。
    其核心思想是：既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。
 3. 2PC(2段式提交)
    JPA规范： atomik框架
    主要分为: 协调者和参与者
    阶段一， 提交事务请求
        1. 事务询问：协调者向所有参与者发送事务内容。询问是否可以执行事务提交操作，并开始等待各参与者的响应。
        2. 执行事务：各参与者节点之行事务操作。并将undo和redo信息记录到事务日志中。
        3. 各参与者向协调者反馈事务询问的响应。如果参与者之行成功了事务，则返回yes，表示事务可以执行。如果参与者没有成功执行事务，那么反馈给协调者no,表示事务不可执行。该操作类似与投票的操作。
    阶段二，执行事务提交
        1。参与者返回都是yes.  则执行：1. 协调者发送提交请求。2。参与者事务提交。3。参与者反馈事务提交结果。4。协调者完成事务。
    缺点：
        单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在***阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。
        同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。
        数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能。
        大事务
    优点：
        尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于 MySQL 是从 5.5 开始支持。
 4. 3PC(3段式提交)
   相比二段式提交做如下更改：
   1、引入超时机制。同时在协调者和参与者中都引入超时机制。
   2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
   CanCommit阶段
      3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。
   PreCommit阶段
      协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。
      1.发送预提交请求 协调者向参与者发送PreCommit请求，并进入Prepared阶段。
      2.事务预提交 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
      3.响应反馈 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。
     假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。
          1.发送中断请求 协调者向所有参与者发送abort请求。
          2.中断事务 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。
     doCommit阶段
     该阶段进行真正的事务提交，也可以分为以下两种情况。
     1. 执行提交：
         1.发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
         2.事务提交 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
         3.响应反馈 事务提交完之后，向协调者发送Ack响应。
         4.完成事务 协调者接收到所有参与者的ack响应之后，完成事务。
     2. 中断事务 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。
        1.发送中断请求 协调者向所有参与者发送abort请求
        2.事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
        3.反馈结果 参与者完成事务回滚之后，向协调者发送ACK消息
        4.中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。
        在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）

        相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。
    TCC：try-confirm-cancel: 两阶段补偿型方案，类似于事务补偿机制。比2pc要好很多，锁粒度要小
        框架：Atomikos,tcc-transaction,ByteTcc,淘宝GTS等。。。。
        Try阶段：
            完成所有业务检查（一致性），预留业务资源(准隔离性)
        Confirm阶段：
            确认执行业务操作，不做任何业务检查， 只使用Try阶段预留的业务资源。
        Cancel阶段：
            取消Try阶段预留的业务资源。

        CC两阶段提交与XA两阶段提交的区别是：
            XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。
            XA事务中的两阶段提交内部过程是对开发者屏蔽的，回顾我们之前讲解JTA规范时，通过UserTransaction的commit方法来提交全局事务，这只是一次方法调用，其内部会委派给TransactionManager进行真正的两阶段提交，因此开发者从代码层面是感知不到这个过程的。而事务管理器在两阶段提交过程中，从prepare到commit/rollback过程中，资源实际上一直都是被加锁的。如果有其他人需要更新这两条记录，那么就必须等待锁释放。
            TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。
            TCC中的两阶段提交并没有对开发者完全屏蔽，也就是说从代码层面，开发者是可以感受到两阶段提交的存在。如上述航班预定案例：在第一阶段，航空公司需要提供try接口(机票资源预留)。在第二阶段，航空公司提需要提供confirm/cancel接口(确认购买机票/取消预留)。开发者明显的感知到了两阶段提交过程的存在。try、confirm/cancel在执行过程中，一般都会开启各自的本地事务，来保证方法内部业务逻辑的ACID特性。其中：
                1、try过程的本地事务，是保证资源预留的业务逻辑的正确性。
                2、confirm/cancel执行的本地事务逻辑确认/取消预留资源，以保证最终一致性，也就是所谓的补偿型事务(Compensation-Based Transactions)。
        由于是多个独立的本地事务，因此不会对资源一直加锁。
        事务补偿：
            事务补偿是一个独立的支持ACID特性的本地事务，用于在逻辑上取消服务提供者上一个ACID事务造成的影响，对于一个长事务(long-running transaction)，与其实现一个巨大的分布式ACID事务，不如使用基于补偿性的方案，把每一次服务调用当做一个较短的本地ACID事务来处理，执行完就立即提交

    MQ的事务